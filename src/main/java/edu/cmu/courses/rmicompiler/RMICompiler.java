package edu.cmu.courses.rmicompiler;

import com.beust.jcommander.JCommander;
import com.beust.jcommander.Parameter;
import edu.cmu.courses.rmi.RemoteStub;

import javax.tools.JavaCompiler;
import javax.tools.JavaFileObject;
import javax.tools.StandardJavaFileManager;
import javax.tools.ToolProvider;
import java.io.*;
import java.lang.reflect.Method;
import java.net.MalformedURLException;
import java.net.URL;
import java.net.URLClassLoader;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

public class RMICompiler {
    private static RMICompiler singleton = null;

    @Parameter(names = {"-cp", "--classpath"},
               description = "the path jrmi-compiler uses to look up classes.")
    private List<String> classPaths = new ArrayList<String>();

    @Parameter(names = {"-d", "--directory"},
               description = "the output directory of the stub file(s)")
    private String outputDirectory = ".";

    @Parameter(names = {"-h", "--help"},
               help = true)
    private boolean help;

    @Parameter(description = "package qualified class name(s)",
            required = true)
    private List<String> implClassNames = new ArrayList<String>();

    private URLClassLoader urlClassLoader;

    private RMICompiler(){

    }

    public boolean needHelp(){
        return help;
    }

    public static RMICompiler getCompiler(){
        if(singleton == null)
            singleton = new RMICompiler();
        return singleton;
    }

    public void compile()
            throws UnsupportedClassException, ClassNotFoundException, IOException {
        loadClassPath();
        for(String implClassName : implClassNames){
            RemoteClass remoteClass = new RemoteClass(implClassName, urlClassLoader);
            Class implClass = remoteClass.getImplClass();
            File outputFile = new File(outputDirectory + File.separator +
                    implClass.getSimpleName() + RemoteStub.STUB_SUFFIX + ".java");
            FileWriter writer = new FileWriter(outputFile);
            writeStub(remoteClass, new IndentingWriter(writer));
        }
    }

    private void loadClassPath() throws MalformedURLException {
        URL urls[] = new URL[classPaths.size()];
        for(int i = 0; i < classPaths.size(); i++){
            String classPath = classPaths.get(i);
            URL url = new File(classPath).toURI().toURL();
            urls[i] = url;
        }
        if(urls.length == 0){
            urls = new URL[] {new File(System.getProperty("user.dir")).toURI().toURL()};
        }
        urlClassLoader = new URLClassLoader(urls, RMICompiler.class.getClassLoader());
    }

    private void writeStub(RemoteClass remoteClass, IndentingWriter out)
            throws IOException, UnsupportedClassException {
        Class implClass = remoteClass.getImplClass();
        Package implClassPackage = implClass.getPackage();
        Class remoteInterfaces[] = remoteClass.getRemoteInterfaces();
        Method remoteMethods[] = remoteClass.getRemoteMethods();
        out.pln("// Stub class source file generated by jrmi-compiler, do not edit it");
        out.pln();

        if(implClassPackage != null){
            out.pln("package " + implClassPackage.getName() + ";");
            out.pln();
        }
        out.pOlnI("public final class " + nameStubClass(implClass));
        out.pln("extends " + RemoteClass.REMOTE_STUB_CLASS);
        out.p("implements ");
        for(int i = 0; i < remoteInterfaces.length; i++){
            Class remoteInterface = remoteInterfaces[i];
            if(i > 0)
                out.p(", ");
            out.p(remoteInterface.getCanonicalName());
        }

        out.pln();
        out.pOlnI("{");
        out.pln();

        writeMethodFieldDeclarations(remoteMethods, out);

        out.plnI("static {");
        out.pI();
        out.plnI("try {");
        out.pI();

        writeMethodFieldInitializers(remoteMethods, out);

        out.pOlnI("} catch (java.lang.NoSuchMethodException e) {");
        out.pI();
        out.plnI("throw new java.lang.NoSuchMethodError(" +
                "\"stub class initialization failed\");");
        out.pO();
        out.pO();
        out.pOln("}");
        out.pO();
        out.pOln("}");
        out.pln();

        writeStubConstructors(implClass, out);
        out.pln();

        for(int i = 0; i < remoteMethods.length; i++){
            Method method = remoteMethods[i];
            out.pln();
            writeStubMethod(method, i, out);
        }

        out.pO();
        out.pOln("}");
        out.flush();
    }

    private void writeStubConstructors(Class implClass, IndentingWriter out)
            throws IOException{
        out.plnI("public " + nameStubClass(implClass) +
                "() {");
        out.pln("super();");
        out.pOln("}");

        out.plnI("public " + nameStubClass(implClass) +
                "(" + RemoteClass.REMOTE_REF_CLASS + " ref) {");
        out.pln("super(ref);");
        out.pOln("}");
    }

    private void writeMethodFieldDeclarations(Method remoteMethods[], IndentingWriter out)
            throws IOException{
        for(int i = 0; i < remoteMethods.length; i++){
            Method method = remoteMethods[i];
            out.pln("private static java.lang.reflect.Method " +
                nameMethodField(method, i) + ";");
        }
    }

    private void writeMethodFieldInitializers(Method remoteMethods[], IndentingWriter out)
            throws IOException{
        for(int i = 0; i < remoteMethods.length; i++){
            Method method = remoteMethods[i];
            Class declaringClass = method.getDeclaringClass();
            Class parameterTypes[] = method.getParameterTypes();
            out.p(nameMethodField(method, i) + " = ");
            out.p(declaringClass.getCanonicalName() + ".class.getMethod(\"" +
                    method.getName() + "\", new java.lang.Class[] {");
            for (int j = 0; j < parameterTypes.length; j++) {
                if (j > 0)
                    out.p(", ");
                out.p(parameterTypes[j].getCanonicalName() + ".class");
            }
            out.pln("});");
        }
    }

    private void writeStubMethod(Method method, int index, IndentingWriter out)
            throws IOException, UnsupportedClassException {
        String methodName = method.getName();
        Class returnType = method.getReturnType();
        Class parameterTypes[] = method.getParameterTypes();
        Class exceptionTypes[] = method.getExceptionTypes();

        out.p("public " + returnType.getCanonicalName() + " " + methodName + "(");
        for (int i = 0; i < parameterTypes.length; i++) {
            if (i > 0)
                out.p(", ");
            out.p(parameterTypes[i].getCanonicalName() + " " + nameParameters(i));
        }
        out.plnI(")");
        out.pI();
        out.pI();
        out.p("throws ");
        for (int i = 0; i < exceptionTypes.length; i++) {
            if (i > 0)
                out.p(", ");
            out.p(exceptionTypes[i].getCanonicalName());
        }
        out.p(" {");
        out.pln();
        out.pO();
        if(returnType != Void.TYPE){
            out.p("Object $result = ");
        }
        out.p("invoke(" + nameMethodField(method, index) + ", ");
        if(parameterTypes.length > 0){
            out.p("new java.lang.Object[] {");
            for(int i = 0; i < parameterTypes.length; i++){
                if(i > 0)
                    out.p(", ");
                out.p(nameParameters(i));
            }
            out.p("}");
        } else {
            out.p("null");
        }
        out.pln(");");
        if(returnType != Void.TYPE){
            out.pln("return (" + marshalReturnType(returnType) + ")$result;");
        }
        out.pO();
        out.pOln("}");
    }

    private String nameStubClass(Class implClass){
        return implClass.getSimpleName() + RemoteStub.STUB_SUFFIX;
    }

    private String nameMethodField(Method method, int index){
        return "$method_" + method.getName() + "_" + index;
    }

    private static String nameParameters(int index) {
        return "$param_" + index;
    }

    private String marshalReturnType(Class returnType)
            throws UnsupportedClassException {
        if(returnType.isPrimitive()){
            if (returnType == int.class) {
                return Integer.class.getCanonicalName();
            } else if (returnType == boolean.class) {
                return Boolean.class.getCanonicalName();
            } else if (returnType == byte.class) {
                return Byte.class.getCanonicalName();
            } else if (returnType == char.class) {
                return Character.class.getCanonicalName();
            } else if (returnType == short.class) {
                return Short.class.getCanonicalName();
            } else if (returnType == long.class) {
                return Long.class.getCanonicalName();
            } else if (returnType == float.class) {
                return Float.class.getCanonicalName();
            } else if (returnType == double.class) {
                return Double.class.getCanonicalName();
            } else {
                throw new UnsupportedClassException("Unrecognized primitive type: " +
                        returnType.getCanonicalName());
            }
        } else {
           return returnType.getCanonicalName();
        }
    }

    public static void main(String[] args)
            throws UnsupportedClassException, IOException, ClassNotFoundException {
        RMICompiler compiler = RMICompiler.getCompiler();
        JCommander jCommander = new JCommander(compiler, args);
        if(compiler.needHelp()){
            jCommander.usage();
        } else {
            compiler.compile();
        }
    }
}
